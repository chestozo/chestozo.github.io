<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ns.History Node.js v0.10.17 Manual &amp; Documentation</title>
  <link rel="stylesheet" href="assets/style.css">
  <link rel="stylesheet" href="assets/sh.css">
  <link rel="canonical" href="http://nodejs.org/api/all.md.html">
</head>
<body class="alt apidoc" id="api-section-all.md">
    <div id="intro" class="interior">
        <a href="/" title="Go back to the home page">
            <img id="logo" src="http://nodejs.org/images/logo-light.png" alt="node.js">
        </a>
    </div>
    <div id="content" class="clearfix">
        <div id="column2" class="interior">
            <ul>
                <li><a href="/" class="home">Home</a></li>
                <li><a href="/download/" class="download">Download</a></li>
                <li><a href="/about/" class="about">About</a></li>
                <li><a href="http://npmjs.org/" class="npm">npm Registry</a></li>
                <li><a href="http://nodejs.org/api/" class="docs current">Docs</a></li>
                <li><a href="http://blog.nodejs.org" class="blog">Blog</a></li>
                <li><a href="/community/" class="community">Community</a></li>
                <li><a href="/logos/" class="logos">Logos</a></li>
                <li><a href="http://jobs.nodejs.org/" class="jobs">Jobs</a></li>
            </ul>
            <p class="twitter"><a href="http://twitter.com/nodejs">@nodejs</a></p>
        </div>

        <div id="column1" class="interior">
          <header>
            <h1>Node.js v0.10.17 Manual &amp; Documentation</h1>
            <div id="gtoc">
              <p>
                <a href="index.html" name="toc">Index</a> |
                <a href="all.html">View on single page</a> |
                <a href="all.md.json">View as JSON</a>
              </p>
            </div>
            <hr>
          </header>

          <div id="toc">
            <h2>Table of Contents</h2>
            <ul>
<li><a href="#all_md_ns_history">ns.History</a><ul>
<li><a href="#all_md_polyfill_ie">Polyfill для IE</a></li>
</ul>
</li>
<li><a href="#all_md">Инициализация приложения</a><ul>
<li><a href="#all_md_1">Конфигурация</a><ul>
<li><a href="#all_md_url">Базовый путь в URL</a></li>
<li><a href="#all_md_2">Заголовок страницы</a></li>
<li><a href="#all_md_url_1">URL запроса моделей</a></li>
<li><a href="#all_md_3">Дополнительные параметры при запросе моделей</a></li>
<li><a href="#all_md_4">Условная обработка ответа моделей</a></li>
<li><a href="#all_md_yate">Переопределение модуля Yate-шаблонов</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#all_md_ns_layout">Раскладка страницы (ns.Layout)</a><ul>
<li><a href="#all_md_5">Бокс</a></li>
<li><a href="#all_md_6">Асинхронные виды</a></li>
</ul>
</li>
<li><a href="#all_md_7">Наследование</a></li>
<li><a href="#all_md_ns_model">ns.Model</a><ul>
<li><a href="#all_md_8">Декларация</a><ul>
<li><a href="#all_md_ctor">ctor</a></li>
<li><a href="#all_md_events"><code>events</code></a></li>
<li><a href="#all_md_methods">methods</a></li>
<li><a href="#all_md_params">params</a></li>
</ul>
</li>
<li><a href="#all_md_9">Получение экземпляра модели</a></li>
<li><a href="#all_md_10">Работа с данными</a></li>
<li><a href="#all_md_11">Пре- и постобработка данных</a><ul>
<li><a href="#all_md_extractdata">extractData</a></li>
<li><a href="#all_md_extracterror">extractError</a></li>
<li><a href="#all_md_hasdatachanged">hasDataChanged</a></li>
<li><a href="#all_md_preprocessdata">preprocessData</a></li>
</ul>
</li>
<li><a href="#all_md_12">События</a></li>
</ul>
</li>
<li><a href="#all_md_ns_modelcollection">ns.ModelCollection</a><ul>
<li><a href="#all_md_13">Декларация</a></li>
</ul>
</li>
<li><a href="#all_md_ns_page">Переходы по страницам (ns.page)</a></li>
<li><a href="#all_md_ns_page_block">ns.page.block</a></li>
<li><a href="#all_md_ns_page_history">ns.page.history</a></li>
<li><a href="#all_md_ns_router">ns.router</a><ul>
<li><a href="#all_md_api">API</a><ul>
<li><a href="#all_md_ns_router_basedir_string"><code>ns.router.baseDir</code>: <code>{string}</code></a></li>
<li><a href="#all_md_ns_router_url_page_string_params_object"><code>ns.router(url)</code>: <code>{ page:string, params:{object} }</code></a></li>
<li><a href="#all_md_ns_router_url_url_string"><code>ns.router.url(url)</code>: <code>{ string }</code></a></li>
<li><a href="#all_md_ns_router_generateurl_id_params_string"><code>ns.router.generateUrl(id, params)</code>: <code>{string}</code></a></li>
<li><a href="#all_md_ns_router_routes_object"><code>ns.router.routes</code>: <code>{object}</code></a></li>
<li><a href="#all_md_ns_router_regexps_object"><code>ns.router.regexps</code>: <code>{object}</code></a></li>
</ul>
</li>
<li><a href="#all_md_14">Параметры</a></li>
</ul>
</li>
<li><a href="#all_md_ns_view">ns.View</a><ul>
<li><a href="#all_md_15">Декларация</a><ul>
<li><a href="#all_md_ctor_1">ctor</a></li>
<li><a href="#all_md_events_1"><code>events</code></a><ul>
<li><a href="#all_md_dom">DOM-события</a></li>
<li><a href="#all_md_noscript">&quot;Космические&quot; события noscript</a></li>
<li><a href="#all_md_16">Встроенные события</a></li>
</ul>
</li>
<li><a href="#all_md_methods_1">methods</a></li>
<li><a href="#all_md_models">models</a></li>
<li><a href="#all_md_17">Параметры</a><ul>
<li><a href="#all_md_params_1">params+</a></li>
<li><a href="#all_md_params_2">params-</a></li>
<li><a href="#all_md_params_3">params</a></li>
</ul>
</li>
<li><a href="#all_md_rewriteparamsoninit">rewriteParamsOnInit</a></li>
</ul>
</li>
<li><a href="#all_md_18">Валидность</a></li>
<li><a href="#all_md_19">Взаимодействие</a></li>
<li><a href="#all_md_async">async</a></li>
</ul>
</li>
<li><a href="#all_md_ns_viewcollection">ns.ViewCollection</a><ul>
<li><a href="#all_md_20">Декларация</a></li>
</ul>
</li>
<li><a href="#all_md_21">Страница</a><ul>
<li><a href="#all_md_22">Адрес страницы</a></li>
</ul>
</li>
<li><a href="#all_md_23">Ключевые сущности</a><ul>
<li><a href="#all_md_24">Параметры страницы</a></li>
<li><a href="#all_md_25">Маршрутизатор</a></li>
<li><a href="#all_md_26">Модель</a></li>
<li><a href="#all_md_27">Вид</a></li>
<li><a href="#all_md_28">Раскладка страницы</a></li>
<li><a href="#all_md_29">Контроллер обновления</a></li>
</ul>
</li>
</ul>

          </div>

          <div id="apicontent">
            <h1>ns.History<span><a class="mark" href="#all_md_ns_history" id="all_md_ns_history">#</a></span></h1>
<p>В noscript для смены URL в адресной строке используется HTML5 History API, который не поддерживается <a href="http://caniuse.com/#feat=history">в IE раньше 10</a>.

</p>
<h2>Polyfill для IE<span><a class="mark" href="#all_md_polyfill_ie" id="all_md_polyfill_ie">#</a></span></h2>
<p>В качестве полифилла можно использовать <a href="https://github.com/devote/HTML5-History-API">devote/HTML5-History-API</a>. Скрипт предоставляет стандартизированное API и будет использовать смену хеш-фрагмента URL для навигации.

</p>
<pre><code>/notes/141 -&gt; /#/notes/141</code></pre>
<p>Кроме подключения самого скрипта на страницу нужно проделать небольшую работу:

</p>
<ol>
<li>Организовать редирект до старта приложения:</li>
</ol>
<pre><code class="js">// Тут может произойти смена URL и перезагрузка, поэтому какие-нибудь
// модели до редиректа запрашивать бессмысленно.
window.history.redirect();

ns.init();</code></pre>
<ol>
<li>Переопределить вычисление текущего URL приложения:</li>
</ol>
<pre><code class="js">var history = window.history;

if (history.emulate) {
    ns.page.getCurrentUrl = function() {
        return history.location.pathname + history.location.search;
    };
}</code></pre>
<h1>Инициализация приложения<span><a class="mark" href="#all_md" id="all_md">#</a></span></h1>
<p>При использовании конфигурации по умолчанию вся инициализация сводится к вызову
функции <code>ns.init</code> и запуску первого апдейта:

</p>
<pre><code class="js">$(function() {
    ns.init();
    ns.page.go();
});</code></pre>
<p><code>ns.init</code> включает экшены, обрабатывает предварительно заданный роутинг и ищет
в DOM ноду <code>#app</code> для использования ее в качестве контейнера для интерфейса.
Вызов <code>ns.page.go</code> нужен для запуска первого глобального апдейта.

</p>
<h2>Конфигурация<span><a class="mark" href="#all_md_1" id="all_md_1">#</a></span></h2>
<h3>Базовый путь в URL<span><a class="mark" href="#all_md_url" id="all_md_url">#</a></span></h3>
<p>До инициализации можно задать префиксный путь для всех ссылок. Это может
пригодиться, когда ваше приложение находится не по корневому пути
<code>app.example.com</code>, а, например, <code>app.example.com/checkout</code>:

</p>
<pre><code class="js">ns.router.baseDir = &#39;/checkout&#39;;</code></pre>
<h3>Заголовок страницы<span><a class="mark" href="#all_md_2" id="all_md_2">#</a></span></h3>
<p>Noscript позволяет задавать заголовок страницы, зависящий от текущего URL,
при переходах внутри приложения. Переопределите функцию <code>ns.page.title</code>:

</p>
<pre><code class="js">ns.page.title = function(url) {
    if (&#39;/settings&#39; == url) {
        return &#39;App - Account Settings&#39;
    }

    return &#39;App&#39;;
};</code></pre>
<p><em>Примечание</em>: При необходимости, для получения параметров страницы
из полученного URL можно воспользоваться функцией <code>ns.router</code>:

</p>
<pre><code class="js">ns.page.title = function(url) {
    var params = ns.router(url).params;
    // ...
};</code></pre>
<h3>URL запроса моделей<span><a class="mark" href="#all_md_url_1" id="all_md_url_1">#</a></span></h3>
<p>По умолчанию фреймворк группирует запросы моделей, нужных для отрисовки
интерфейса и запрашивает их по URL <code>/models/</code> <em>вне зависимости
от <code>ns.router.baseDir</code></em>. Переопределите константу <code>ns.request.URL</code> для задания
собственного пути:

</p>
<pre><code class="js">ns.request.URL = &#39;/models/v1/json/&#39;;</code></pre>
<h3>Дополнительные параметры при запросе моделей<span><a class="mark" href="#all_md_3" id="all_md_3">#</a></span></h3>
<p>При необходимости пробросить дополнительные параметры при запросе моделей,
добавьте их в объект <code>ns.request.requestParams</code>:

</p>
<pre><code class="js">ns.request.requestParams.token = getAuthToken();
ns.request.requestParams.version = &#39;0.1.1&#39;;</code></pre>
<p>Это приведет к отправке запросов вида:

</p>
<pre><code>Request URL: http://example.com/models/?_m=todos

Query String Parameters:
  _m: todos

Form Data:
  category.0: home
  token: 6a5e516725c68c
  version: 0.1.1</code></pre>
<h3>Условная обработка ответа моделей<span><a class="mark" href="#all_md_4" id="all_md_4">#</a></span></h3>
<p>Определение функции <code>ns.request.canProcessResponse</code> позволяет динамически
заблокировать обработку ответа моделей, например, при несовпадении авторизации
или рассинхронизации клиента с бекендом:

</p>
<pre><code class="js">ns.request.canProcessResponse = function(response) {
    // На бекенде выехала новая версия, а текущий клиент засиделся.
    if (response.version != APP.version) {
        location.reload();
        return false;
    }

    return true;
};</code></pre>
<h3>Переопределение модуля Yate-шаблонов<span><a class="mark" href="#all_md_yate" id="all_md_yate">#</a></span></h3>
<p>По умолчанию для генерации разметки из шаблонов используется модуль <code>main</code>,
однако сохраняется возможность его динамического определения в зависимости от
параметров страницы и текущего лейаута:

</p>
<pre><code class="js">ns.Update.prototype.applyTemplate = function(tree, params, layout) {
    var module = &#39;main&#39;;

    if (params.context === &#39;setup&#39;) {
        module = &#39;setup&#39;;
    }

    return ns.renderString(tree, null, module);
};</code></pre>
<h1>Раскладка страницы (ns.Layout)<span><a class="mark" href="#all_md_ns_layout" id="all_md_ns_layout">#</a></span></h1>
<p>Раскладка служит для декларативного описания структуры видов на странице. При определении раскладки указывается её id и декларация.

</p>
<pre><code>    ns.layout.define(&#39;main&#39;, {
        app: {
            view1: true,
            view2: {
                view21: true
            }
        }
    });</code></pre>
<p>В примере создаётся раскладка страницы, состоящей из четырёх видов. Корневой вид <code>app</code> содержит в себе <code>view1</code> и <code>view2</code>, а <code>view2</code> содержит в себе <code>view21</code>.

</p>
<p>Каждый узел декларации соответствует виду. Ключ указывает на класс вида, в значении содержится декларация вложенных видов.

</p>
<p>Способы описания структуры видов

</p>
<pre><code>    ns.layout.define(&#39;main&#39;, {
        app: {

            // Для описания вида без вложенностей значение устанавливается в true
            view1: true,

            // Для описания одного вложенного вида в значении указывается его класс
            view2: &#39;view21&#39;,

            // Для описания статической структуры видов используется объект
            view3: {
                view31: true,
                view32: &#39;view321&#39;
            },
            // Для описания динамической структуры видов узел объяляется боксом,
            // а вложенность задаётся функцией.
            // В params приходят параметры страницы.
            // Функция может вернуть любой из выше перечисленных форматов декларации
            // видов, или falsy, чтобы отменить добавление вида в страницу.
            view4@: function(params) {
                if (params.value1) {
                    return null;
                }
                if (params.value2) {
                    return &#39;view41&#39;;
                }
                if (params.value3) {
                    return {
                        &#39;view42&#39;: {
                            &#39;view421&#39;: true;
                        }
                    };
                }
            }
        }
    });</code></pre>
<p>Кроме описания структуры видов раскладка так же позволяет декларировать специальные атрибуты видов.

</p>
<h2>Бокс<span><a class="mark" href="#all_md_5" id="all_md_5">#</a></span></h2>
<p>Бокс - это специальный вид-контейнер. Он не имеет собственного html-содержимого и представлен в DOM только одним узлом, содержащим непосредственно в себе все вложенности. Бокс позволяет решать следующие задачи.


</p>
<p>Кеширование экземпляров вида

</p>
<pre><code>    ns.layout.define(&#39;main&#39;, {
        app: {
            box@: &#39;view1&#39;
        }
    });</code></pre>
<p>В примере <code>box</code> будет содержать один вложенный вид <code>view1</code>. Если <code>view1</code> зависит от параметров, то при изменении параметров предыдущие html-узлы будут скрываться, но оставаться в DOM-дереве, а новые - добавляться в <code>box</code> и показываться. При возврате к одному из предыдущих наборов параметров будет показан ранее сгенерированный соответствующий ему html-узел.


</p>
<p>Создание динамической раскладки

</p>
<pre><code>    ns.layout.define(&#39;main&#39;, {
        app: {
            view1: true,
            view2@: function(params) {
                if (params.value1) {
                    return null;
                }
                if (params.value2) {
                    return &#39;view41&#39;;
                }
                if (params.value3) {
                    return {
                        &#39;view42&#39;: &#39;view421&#39;,
                        &#39;view43&#39;: &#39;view431&#39;
                    };
                }
            }
        }
    });</code></pre>
<p>В примере вид в зависимости от параметров может отсутствовать, содержать единственный вид <code>view41</code>, или содержать <code>view42</code> и <code>view43</code>, содержащие в свою очередь соответственно <code>view421</code> и <code>view431</code>. Для создания такой структуры <code>view2</code> обязательно должен быть боксом. Обычный view, содержащий вложенные виды, при их исчезновении после обновления может работать некорректно.

</p>
<h2>Асинхронные виды<span><a class="mark" href="#all_md_6" id="all_md_6">#</a></span></h2>
<p>Асинхронный вид позволяет на время загрузки его моделей рисовать его в виде заглушки. Updater запросит модели асинхронных видов отдельными запросами и отрисует страницу до получения этих данных. Загрузив модели, Updater сделает повторный проход только по асинхронным видам и обновит их.

</p>
<pre><code>    ns.layout.define(&#39;main&#39;, {
        app: {
            viewLight: true,
            viewHard&amp;: true
        }
    });</code></pre>
<pre><code>    ns.View.define(&#39;viewLight&#39;, {
        models: [&#39;modelLight&#39;]
    })
    ns.View.define(&#39;viewHard&#39;, {
        models: [&#39;modelHard&#39;]
    })</code></pre>
<pre><code>    match .view[id=&quot;viewLight&quot;] ns-view {
        // основное html-содержимое вида viewLight
    }


    match .view[id=&quot;viewHard&quot;] ns-view-async {
        // html-содержимое заглушки для вида viewHard
    }
    match .view[id=&quot;viewHard&quot;] ns-view {
        // основное html-содержимое вида viewHard
    }</code></pre>
<p>Предположим, что modelLight запросить легко, а запрос modelHard требует заметного времени. При обновлении Updater запросит модели отдельно: сначала modelLight, а затем modelHard. Получив данные для modelLight, Updater отрисует страницу. Вид viewHard при этом отрисуется в виде заглушки (с использованием шаблона ns-view-async). После получения данных для modelHard Updater сделает ещё один такт обновления и вместо заглушки отрисует основное содержимое viewHard.

</p>
<h1>Наследование<span><a class="mark" href="#all_md_7" id="all_md_7">#</a></span></h1>
<p>Один layout может наследовать от другого. Наследование реализуется следующим образом

</p>
<pre><code class="js">// объявляет общий layout для всех страниц
ns.layout.define(&#39;common&#39;, {
    &#39;app&#39;: {
        // каждая страница в проекте состоит из шапки, левой колонки и правой колонки
        &#39;header-box@&#39;: {},
        &#39;left-box@&#39;: {},
        &#39;right-box@&#39;: {},
    }
});

// страница 1
// обратите внимание, что header-box@ не доопределяелся и берется как есть из common
ns.layout.define(&#39;posts&#39;, {
    // чтобы заново не описывать структуру, путь до видов указывается через пробел
    &#39;app left-box@&#39;: {
        &#39;navigation&#39;: {}
    },
    &#39;app right-box@&#39;: {
        &#39;posts&#39;: {}
    }
// последним параметром для ns.layout.define указывает, что layout наследуется от common
}, &#39;common&#39;);

// страница 2
ns.layout.define(&#39;profile&#39;, {
    &#39;app header-box@&#39;: {
        &#39;user-header&#39;: {}
    },
    &#39;app left-box@&#39;: {
        &#39;navigation&#39;: {}
    },
    &#39;app right-box@&#39;: {
        &#39;profile&#39;: {}
    }
}, &#39;common&#39;);</code></pre>
<h1>ns.Model<span><a class="mark" href="#all_md_ns_model" id="all_md_ns_model">#</a></span></h1>
<p>Модель представляет собой данные.
Она однозначно идентифицируется своим ключом, который строится во время инициализации.
Разный ключ всегда означает разный экземпляр модели.

</p>
<ul>
<li><a href="#Декларация">Декларация</a><ul>
<li><a href="#ctor">ctor</a></li>
<li><a href="#events">events</a></li>
<li><a href="#methods">methods</a></li>
<li><a href="#params">params</a></li>
</ul>
</li>
<li><a href="#Получение-экземпляра-модели">Получение экземпляра модели</a></li>
<li><a href="#Работа-с-данными">Работа с данными</a></li>
<li><a href="#Пре--и-постобработка-данных">Постобработка данных</a><ul>
<li><a href="#extractdata">extractData</a></li>
<li><a href="#extracterror">extractError</a></li>
<li><a href="#hasdatachanged">hasDataChanged</a></li>
<li><a href="#preprocessdata">preprocessData</a></li>
</ul>
</li>
<li><a href="#События">События</a></li>
</ul>
<h2>Декларация<span><a class="mark" href="#all_md_8" id="all_md_8">#</a></span></h2>
<p>Определение новой модели происходит через статическую функцию <code>ns.Model.define</code>
</p>
<pre><code class="js">ns.Model.define(&#39;modelName&#39;, modelDeclObject[, baseModel])</code></pre>
<p>Объект-декларация состоит из следующих свойств.

</p>
<h3>ctor<span><a class="mark" href="#all_md_ctor" id="all_md_ctor">#</a></span></h3>
<p><code>ctor</code> - это функция-конструтор. Обратите внимание, что он вызывается самым первым, до инициализации самой модели, т.о. в конструкторе еще не доступны некоторые свойства.

</p>
<p>Полностью готовый экземпляр бросает событие <code>ns-model-init</code>.

</p>
<pre><code class="js">/**
 * @classdesc prj.mMyModel
 * @augments ns.Model
 */
ns.Model.define(&#39;my-model&#39;, {
    /**
     * @constructs prj.mMyModel
     */
    ctor: function() {
        this._state = &#39;initial&#39;;
        this.CONST = 100;
    }
});</code></pre>
<h3><code>events</code><span><a class="mark" href="#all_md_events" id="all_md_events">#</a></span></h3>
<p><code>events</code> - объект с декларацией подписок на события noscript.

</p>
<p>Любая подписка имеет вид:
</p>
<pre><code class="json">{
    &quot;на что подписаться&quot;: &quot;обработчик&quot;
}</code></pre>
<p>Обработчиком может быть название метода из прототипа или функция.

</p>
<p>Пример:
</p>
<pre><code class="js">{
    &quot;my-custom-event&quot;: &quot;onCustomEvent&quot;,
    &quot;my-custom-show@show&quot;: &quot;onCustomShow&quot;
}</code></pre>
<h3>methods<span><a class="mark" href="#all_md_methods" id="all_md_methods">#</a></span></h3>
<p><code>methods</code> - объект с методами. По сути является прототипом объекта.

</p>
<pre><code class="js">/**
 * @classdesc prj.mMyModel
 * @augments ns.Model
 */
ns.Model.define(&#39;my-model&#39;, {
    /** @lends prj.mMyModel.prototype */
    methods: {
        BAR: 100
        foo: function(){}
    }
});</code></pre>
<h3>params<span><a class="mark" href="#all_md_params" id="all_md_params">#</a></span></h3>
<p>Параметры нужны для как для построения ключа, так и для запроса моделей с сервера.

</p>
<pre><code class="js">ns.Model.define(&#39;my-model&#39;, {
    params: {
        //  Любое значение, кроме null расценивается как дефолтное значение этого параметра.
        &#39;author-login&#39;: null,
        &#39;album-id&#39;: null,

        //  Этим двум параметрам заданы дефолтные значения.
        &#39;page&#39;: 0,
        &#39;pageSize&#39;: 20
    }
});</code></pre>
<h2>Получение экземпляра модели<span><a class="mark" href="#all_md_9" id="all_md_9">#</a></span></h2>
<div class="signature"><ul>
<li><code>ns.Model.get(&#39;modelName&#39;, params)</code> - строит ключ из <code>params</code> и возвращает соответствующую модель. Если такого экземпляра нет, то он будет создан.</li>
<li><code>ns.Model.getValid(&#39;modelName&#39;, params)</code> - тоже самое что и <code>ns.Model.get</code>. Только экземпляр еще проверяется на валидность. Если валидный экземпляр не найден, то возвращается <code>null</code>.</li>
</div></ul>
<h2>Работа с данными<span><a class="mark" href="#all_md_10" id="all_md_10">#</a></span></h2>
<p><strong>Методы для получения данных</strong>:
 - <code>#getData()</code> - возвращает весь объект данных модели. Этот метод можно переопределять для доп. обработки данных. Например, для коллекции этот метод собирает актуальные данных из всех элементов.
 - <code>#get(jpath)</code> - выбирает данные по jpath и приводит результат к упрощенному виду. Результат приведения зависит как от самих данных, так и от jpath. Поэтому при изменениях формат результата может меняться.
</p>
<pre><code class="js">{
    &quot;foo&quot;: &quot;1&quot;,
    &quot;bar&quot;: [
        { &quot;id&quot;: 1 }
    ]
}
this.get(&#39;.foo&#39;) -&gt; &quot;1&quot;
this.get(&#39;.bar.id&#39;) -&gt; [&quot;1&quot;]</code></pre>
<ul>
<li><code>#select(jpath)</code> - выбирает данные по jpath. В отличии от <code>#get</code>, не занимается приведением и всегда возвращает <strong>массив</strong> результатов выборки, т.о. формат результат остается стабильным при изменениях.<pre><code class="js">{
 &quot;foo&quot;: &quot;1&quot;,
 &quot;bar&quot;: [
     { &quot;id&quot;: 1 }
 ]
}
this.get(&#39;.foo&#39;) -&gt; [&quot;1&quot;]
this.get(&#39;.bar.id&#39;) -&gt; [&quot;1&quot;]</code></pre>
</li>
</ul>
<p><strong>Методы для изменения данных</strong>:
 - <code>#set(jpath, value)</code> - изменяет данные по jpath. Поддерживаются только несложные jpath.
</p>
<pre><code class="js">this.set(&#39;.foo&#39;, 2);</code></pre>
<ul>
<li><code>#setData(data)</code> - устаналивает полностью новые данные. В частности, этот метод вызывается при получении данных с сервера.</li>
</ul>
<h2>Пре- и постобработка данных<span><a class="mark" href="#all_md_11" id="all_md_11">#</a></span></h2>
<h3>extractData<span><a class="mark" href="#all_md_extractdata" id="all_md_extractdata">#</a></span></h3>
<p>Метод извлекает данные из ответа сервера. По умолчанию берется поле <code>data</code> из ответа. Если метод не возвращает данные, то считается, что модель загружена с ошибкой.
</p>
<pre><code class="js">ns.Model.define(&#39;my-model&#39;, {
    methods: {
        extractData: function(serverResponse) {
            if (serverResponse) {
                return serverResponse.result;
            }
        }
    }
});</code></pre>
<h3>extractError<span><a class="mark" href="#all_md_extracterror" id="all_md_extracterror">#</a></span></h3>
<p>Метода извлекает данные об ошибке сервера. По умолчанию берется поле <code>error</code> из ответа.

</p>
<p>Метод вызывается, когда <code>#extractData()</code> не вернул данные.

</p>
<pre><code class="js">ns.Model.define(&#39;my-model&#39;, {
    methods: {
        extractError: function(serverResponse) {
            if (serverResponse) {
                return serverResponse.error;
            }
        }
    }
});</code></pre>
<h3>hasDataChanged<span><a class="mark" href="#all_md_hasdatachanged" id="all_md_hasdatachanged">#</a></span></h3>
<p>Этот метод может контроллировать изменились ли данные на самом деле, чтобы не вызывать лишних события и перерисовок.
Аргументом метода являются новые данные, а старые можно получить способами описанными выше, например <code>#getData</code>. Должен вернуть <code>boolean</code>.

</p>
<pre><code class="js">ns.Model.define(&#39;my-model&#39;, {
    methods: {
        hasDataChanged: function(newData) {
            var oldData = this.getData;
            // изменяем данные, только если изменилось поле id
            return oldData.id !== newData.id
        }
    }
});</code></pre>
<h3>preprocessData<span><a class="mark" href="#all_md_preprocessdata" id="all_md_preprocessdata">#</a></span></h3>
<p>Этот метод позволяет обработать полученные данные.
Аргументом метода являются новые данные, должен вернуть обработанные данные.

</p>
<pre><code class="js">ns.Model.define(&#39;my-model&#39;, {
    methods: {
        _index: null,
        preprocessData: function(newData) {
            var that = this;
            // строим индекс для быстрого поиска
            newData.forEach(function(item) {
                that._index[item.id] = item;
            });
            return newData;
        }
    }
});</code></pre>
<h2>События<span><a class="mark" href="#all_md_12" id="all_md_12">#</a></span></h2>
<div class="signature"><ul>
<li><code>ns-model-changed</code> - модель изменилась. В аргументах приходит jpath, по которому было сделано изменение. Если он пустой, то изменилась вся модель (обычно методом <code>#setData()</code>)</li>
<li><code>ns-model-changed&lt;.jpath&gt;</code> - изменились данные по указанному jpath. В аргументах приходит jpath, по которому было сделано изменение. События кидаются иерархично, т.о. для <code>.for.bar</code> будет три события: <code>ns-model-changed.foo.bar</code>, <code>ns-model-changed.foo</code>, <code>ns-model-changed</code></li>
<li><code>ns-model-destroyed</code> - модель была инвалидированна и уничтожена.</li>
<li><code>ns-model-init</code> - модель создана и проинициализованна</li>
<li><code>ns-model-touched</code> - у модели изменилась версия. Такое событие будет как результатом изменения данных через <code>#set</code> или <code>#setData</code>, так и прямым вызовом метода <code>#touch()</code></li>
</div></ul>
<h1>ns.ModelCollection<span><a class="mark" href="#all_md_ns_modelcollection" id="all_md_ns_modelcollection">#</a></span></h1>
<p><code>ModelCollection</code> - это коллеция (по сути, массив) <code>ns.Model</code>.

</p>
<p>Может иметь собственные данные.
Данные коллекции непосредственно не хранит, а собирает динамически из актуальных <code>ns.Model</code>.

</p>
<p>Коллеция не может содержать одинаковых моделей.

</p>
<p><code>ns.ModelCollection</code> наследуется от <code>ns.Model</code> и добавляет к ней некоторые методы:
 - <code>#clear()</code> - очищает коллекцию
 - <code>#insert(models[, index = last])</code> - добавляет <code>models</code> в коллекцию на позицию <code>index</code>.
 - <code>#remove(models)</code> - удаляет <code>models</code> из коллекции.

</p>
<p>При добавлении элементов бросает событие <code>ns-model-insert</code> со списком новых моделей.

</p>
<p>При удалении элементов бросает событие <code>ns-model-remove</code> со списком удаленных моделей.

</p>
<h2>Декларация<span><a class="mark" href="#all_md_13" id="all_md_13">#</a></span></h2>
<p>Декларация отличается наличием поля <code>split</code>

</p>
<pre><code class="js">ns.Model.define(&#39;my-model-collection&#39;, {
    split: {
        items: &#39;.message&#39;,
        params: {
            &#39;mid&#39;: &#39;.mid&#39;
        },
        model_id: &#39;message&#39;
    }
});</code></pre>
<p><code>split.items</code> - jpath до элементов коллекции. После получения данных коллекции выберет элементы по этому jpath и сделает из каждого элемента модель. Это и будет коллекция.
<code>split.model_id</code> - название модели, из которых будет состоять коллекции
<code>split.params</code> - параметры для элементов коллекции

</p>
<p>Если модель наполняется вручную, то <code>split</code> можно не указывать, а указать флаг <code>isCollection === true</code>.

</p>
<p>Для таких колекций так же можно указать jpath, по которому будет лежать коллекция - <code>jpathItems</code> (по умолчанию, <code>.items</code>).

</p>
<pre><code class="js">ns.Model.define(&#39;my-model-collection&#39;, {
    isCollection: true,
    jpathItems: &#39;.files&#39;
});

ns.Model.define(&#39;my-model-item&#39;, {
    params: {
        id: null
    }
});

var collection = ns.Model.get(&#39;my-model-collection&#39;);
var collectionItem1 = ns.Model.get(&#39;my-model-item&#39;, {id : 1}).setData({&#39;foo&#39;: &#39;bar&#39;});
var collectionItem2 = ns.Model.get(&#39;my-model-item&#39;, {id : 2}).setData({&#39;foo&#39;: &#39;baz&#39;});

// добавляем элементы в коллекцию
collection.insert(collectionItem1);
collection.insert(collectionItem2);

// т.к. указан jpathItems, то данные коллекции будут выглядет вот так
{
    &quot;files&quot;: [
        {
            &quot;foo&quot;: &quot;bar&quot;
        },
        {
            &quot;foo&quot;: &quot;baz&quot;
        }
    ]
}</code></pre>
<h1>Переходы по страницам (ns.page)<span><a class="mark" href="#all_md_ns_page" id="all_md_ns_page">#</a></span></h1>
<p><code>ns.page</code> - специальный модуль для перехода по страницам внутри ns-приложения.

</p>
<p><code>ns.page.go</code> - главный метод. Разроваричивает адрес через <code>ns.router</code>, выбирает <code>layout</code>, запускает <code>ns.Update</code> и
производит необходимые операции по смене урла в адресной строке и обновления названия (<code>document.title</code>) страницы.
Метод возвращает промис от <code>ns.Update</code>, но иногда может вернуть отклоненный промис со статусами:
 - <code>block</code> - переход был заблокирован через <a href="#nspageblock"><code>ns.page.block</code></a>

</p>
<p><code>ns.page.title</code> - точка расширения приложения. Позволяет задавать <a href="./ns.init.md#Заголовок-страницы">заголовки страниц</a>.

</p>
<p>Также модуль предоставляет полезные данные:
 - <code>ns.page.current</code> - текущие параметры страницы
  - <code>ns.page.current.page</code> - название текущего <code>layout</code>
  - <code>ns.page.current.params</code> - текущие параметры
 - <code>ns.page.currentUrl</code> - адрес текущей страницы


</p>
<h1>ns.page.block<span><a class="mark" href="#all_md_ns_page_block" id="all_md_ns_page_block">#</a></span></h1>
<p>Этот механизм позволяет блокировать переходы по страницам.
Например, с помощью него можно блокировать уход с формы, если не были сохранены изменения.

</p>
<pre><code class="js">ns.View.define(&#39;my-view&#39;, {
    events: {
        &#39;ns-view-show&#39;: function() {
            // после показа вида, добавляем функцию блокировки
            ns.page.block.add( this.checkChanges.bind(this) );
        },
        &#39;ns-view-hide&#39;: function() {
            // после скрытия вида, очищаем функции
            ns.page.block.clear();
        }
    },
    methods: {
        /**
         * @param {string} url ссылка, по которой выполняется переход
         */
        checkChanges: function(url) {
            if (this.hasUnsavedChanges()) {
                // здесь можно показать какое-то сообщение

                // функция блокировки должна вернуть false, если переход нельзя осуществить
                return false;
            }

            return true;
        }
    }
 });</code></pre>
<h1>ns.page.history<span><a class="mark" href="#all_md_ns_page_history" id="all_md_ns_page_history">#</a></span></h1>
<p>Этот модуль хранит историю приложения.
Он нужен, т.к. в History API нельзя получить произвольное состояние на N шагов назад.

</p>
<p>Имеет два метода:
 - <code>ns.page.history.back</code> - переход &quot;назад&quot;. Этот метод не аналогичен кнопке &quot;Назад&quot; в браузере. Так, при отсутствии истории, этот метод перейдет на дефолтную страницу приложения (<code>ns.page.getDefaultUrl</code>), а не выйдет из него.
 - <code>ns.page.history.getPrevious(n)</code> - возвращает урл N страниц назад. 0 - предыдующая страница.

</p>
<h1>ns.router<span><a class="mark" href="#all_md_ns_router" id="all_md_ns_router">#</a></span></h1>
<p>Умеет:
- получать из урла - <code>id</code> страницы (layout) и параметры <code>params</code>
- генерировать url-ы по <code>id</code> страницы и параметрам <code>params</code>

</p>
<h2>API<span><a class="mark" href="#all_md_api" id="all_md_api">#</a></span></h2>
<h3><code>ns.router.baseDir</code>: <code>{string}</code><span><a class="mark" href="#all_md_ns_router_basedir_string" id="all_md_ns_router_basedir_string">#</a></span></h3>
<p>Базовая часть урла (если приложение располагается не в корне сайта.

</p>
<h3><code>ns.router(url)</code>: <code>{ page:string, params:{object} }</code><span><a class="mark" href="#all_md_ns_router_url_page_string_params_object" id="all_md_ns_router_url_page_string_params_object">#</a></span></h3>
<p>Выполняет роутинг: вычисляет по <code>url</code> какая это страница <code>page</code> (это <code>id</code> layout-а) и вытаскивает параметры из урла.
Если в урле были GET параметры - они подклеиваются в итоговый набор <code>params</code>.

</p>
<p>Когда выполняется роутинг выполняются:
- (опционально) redirect-ы (получаем новый урл после redirect-а и ещё раз выполняем роутинг)
- (опционально) rewrite (текущий урл заменяется на прописанный в rewrite-е, параметры подклеиваются в конце как GET параметры)
- роутинг (ищем первый подходящий шаблон урла, подробнее см. <code>ns.router.routes</code>. Если не удалось заматчится - считаем, что получили страницу с <code>not-found</code>)
- (опционально) rewrite параметров (при желании, меняем что-то в полученном объекте с параметрами <code>params</code>).

</p>
<h3><code>ns.router.url(url)</code>: <code>{ string }</code><span><a class="mark" href="#all_md_ns_router_url_url_string" id="all_md_ns_router_url_url_string">#</a></span></h3>
<p>Генерация урла, когда урл известен и нужно только дописать базовую часть.
Странный метод, лучше использовать <code>ns.router.generateUrl</code>

</p>
<h3><code>ns.router.generateUrl(id, params)</code>: <code>{string}</code><span><a class="mark" href="#all_md_ns_router_generateurl_id_params_string" id="all_md_ns_router_generateurl_id_params_string">#</a></span></h3>
<p>Генерация урла по <code>id</code> страницы (layout) и по набору параметров.
Это операция, обратная той, которую делает <code>ns.router</code>.
Умеет разворачивать rewrite-ы (после генерации урла проверяет, есть ли <code>rewrite</code> правила для полученного урла и выполняет их в обратную сторону).
В случае неуспеха - кидает ошибку.

</p>
<h3><code>ns.router.routes</code>: <code>{object}</code><span><a class="mark" href="#all_md_ns_router_routes_object" id="all_md_ns_router_routes_object">#</a></span></h3>
<p>Это объект, в котором нужно указать все урлы, rewrite-ы и redirect-ы.
Кроме этого поддерживается rewrite параметров.

</p>
<p><code>redirect</code> - прописываются редиректы. Можно указать шаблон урла, который надо заматчить и можно указать функцию, которая вычисляет, куда делается редирект.

</p>
<p><code>rewriteUrl</code> - тут указаны урлы (не шаблоны урлов) и можно указать rewrite для конкретного урла на другой конкретный урл.

</p>
<p><code>route</code> - тут прописано соответствие шаблона урла - странице (layout-у).
Матчинг урла выполняется сверху вниз. А значит у урла, который выше - больше приоритет.
Отсюда правило - более общие шаблоны урлов указывать ниже.
Матчинг выполняется до первого успешного сопоставления.
Одной и тоже странице может соответствовать несколько шаблонов урлов.

</p>
<p><code>rewriteParams</code> - для страницы (layout-а) можно указать функцию, в которой произвольным образом поменять <code>params</code>.

</p>
<pre><code class="js">ns.router.routes = {
    redirect: {
        &#39;/&#39;: &#39;/inbox&#39;,
        &#39;/inbox/old/{int:int}&#39;: &#39;/inbox&#39;,
        &#39;/inbox/my&#39;: function() {
            return &#39;/inbox&#39;;
        },
        &#39;/inbox/my/{int:int}&#39;: function(params) {
            return &#39;/inbox/&#39; + params.int;
        }
    },
    rewriteUrl: {
        &#39;/page1&#39;: &#39;/page/1&#39;
    },
    route: {
        &#39;/inbox&#39;: &#39;messages&#39;,
        &#39;/message/{mid:int}&#39;: &#39;message&#39;,
        &#39;/page/prefix{page:int}&#39;: &#39;url-with-prefix&#39;,
        &#39;/search/{request:any}&#39;: &#39;search&#39;
    },
    rewriteParams: {
        &#39;message&#39;: function(params) {
            return { id: params.mid };
        }
    }
};</code></pre>
<h3><code>ns.router.regexps</code>: <code>{object}</code><span><a class="mark" href="#all_md_ns_router_regexps_object" id="all_md_ns_router_regexps_object">#</a></span></h3>
<p>Тут задаются типы параметров в виде регулярных выражения.

</p>
<p>Начальный набор такой:
</p>
<pre><code class="js">ns.router.regexps = {
    &#39;id&#39;: &#39;[A-Za-z_][A-Za-z0-9_-]*&#39;,
    &#39;int&#39;: &#39;[0-9]+&#39;
};</code></pre>
<h2>Параметры<span><a class="mark" href="#all_md_14" id="all_md_14">#</a></span></h2>
<p>Параметры в урле задаются в <code>{}</code>, к примеру, <code>/message/{message-id}</code>.
Параметр может быть как между <code>/</code>-ами, так и в промежутках, к примеру, <code>/archive/{year}-{month}-{day}</code>.

</p>
<p>Тип указывается после имени параметра и отделяется <code>:</code>: <code>{page:int}</code>.
Если параметр указан без типа - ему присваивается тип <code>id</code>. Т.е. <code>{message-id}</code> соответствует <code>{message-id:id}</code>.

</p>
<p>Параметр может быть опциональным.
В этом случае, слеш перед ним тоже становится опциональным.
Чтобы указать, что параметр опционален - нужно дописать <code>=</code> или <code>=default</code> после имени параметра (или типа, если он указан),
примерно так: <code>{page=}</code>, <code>{page=0}</code>, <code>{page:int=}</code> или <code>{page:int=0}</code>.
Если в исходном урле параметр не задан, но указано дефолтное значение - оно будет в итоговом наборе параметров страницы <code>params</code>.

</p>
<p>Можно указать фильтр значения параметра.
В этом случае параметр должен иметь строго указанное значение, только в этом случае урл будет заматчен.
Чтобы указать фильтр нужно дописать <code>==filter</code> после имени параметра (или типа, если он указан), примерно так: <code>{color==green}</code> или <code>{color:colors==green}</code>.

</p>
<p><strong>Можно указать либо дефолтное значение, либо фильтр</strong>.

</p>
<p>@include ns.update.logic
</p>
<h1>ns.View<span><a class="mark" href="#all_md_ns_view" id="all_md_ns_view">#</a></span></h1>
<p>Вид представляет собой элемент интерфейса.
Он однозначно идентифицируется своим ключом, который строится во время инициализации исходя из <a href="#Параметры">параметров вида</a>.
Разный ключ всегда означает разный экземпляр вида.

</p>
<p>Не стоит ожидать, что при изменении параметров будет перерисован тот же самый вид.
Этого можно достичь, но в общем виде будет создан и отрисован новый экземпляр.

</p>
<p>Ключ очень важен для работы <code>ns.Box</code>.
<code>ns.Box</code> при каждом обновлении высчитывает ключи для видов, которые должен показать, скрывает все виды, у которых ключ не совпадает и показывает те, которые надо.

</p>
<ul>
<li><a href="#Декларация">Декларация</a><ul>
<li><a href="#ctor">ctor</a></li>
<li><a href="#events">events</a><ul>
<li><a href="#dom-события">DOM-события</a></li>
<li><a href="#События-noscript">&quot;Космические&quot; события noscript</a></li>
<li><a href="#Встроенные-события">Встроенные события</a></li>
</ul>
</li>
<li><a href="#methods">methods</a></li>
<li><a href="#models">models</a></li>
<li><a href="#Параметры">Параметры</a><ul>
<li><a href="#params+">params+</a></li>
<li><a href="#params-">params-</a></li>
<li><a href="#params">params</a></li>
<li><a href="#rewriteParamsOnInit">rewriteParamsOnInit</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Валидность">Валидность и перерисовки</a></li>
<li><a href="#Взаимодействие">Взаимодействие с видом</a></li>
<li><a href="#async">async</a></li>
</ul>
<h2>Декларация<span><a class="mark" href="#all_md_15" id="all_md_15">#</a></span></h2>
<p>Определение нового вида происходит через статическую функцию <code>ns.View.define</code>
</p>
<pre><code class="js">ns.View.define(&#39;viewName&#39;, viewDeclObject[, baseView])</code></pre>
<p>Объект-декларация состоит из следующих свойств.

</p>
<h3>ctor<span><a class="mark" href="#all_md_ctor_1" id="all_md_ctor_1">#</a></span></h3>
<p><code>ctor</code> - это функция-конструтор. Обратите внимание, что он вызывается самым первым, до инициализации самого вида, т.о. в конструкторе еще не доступеы некоторые свойства.

</p>
<p>Полностью готовый экземпляр бросает событие <code>ns-view-init</code>.

</p>
<pre><code>/**
 * @classdesc prj.vMyView
 * @augments ns.View
 */
ns.View.define(&#39;my-view&#39;, {
    /**
     * @constructs prj.vMyView
     */
    ctor: function() {
        this._state = &#39;initial&#39;;
        this.CONST = 100;
    }
});</code></pre>
<h3><code>events</code><span><a class="mark" href="#all_md_events_1" id="all_md_events_1">#</a></span></h3>
<p><code>events</code> - объект с декларацией подписок на события, как DOM, так и noscript.

</p>
<p>Любая подписка имеет вид:
</p>
<pre><code class="json">{
    &quot;на что подписаться@когда&quot;: &quot;обработчик&quot;
}</code></pre>
<p>Обработчиков может быть названием метода из прототипа или функция. Все обработчики вызываются в контексте вида.

</p>
<p>События с суффиксом <code>@show</code> вешаются во время показа вида (событие <code>ns-view-show</code>) и снимаются во время скрытия (событие <code>ns-view-hide</code>).
Аналогично, суффикс <code>@init</code> означает, что событие будет активировано на <code>ns-view-htmlinit</code> и деактивировано на <code>ns-view-htmldestroy</code>.

</p>
<h4>DOM-события<span><a class="mark" href="#all_md_dom" id="all_md_dom">#</a></span></h4>
<p>DOM-события от события noscript различаются согласно массиву <code>ns.V.DOM_EVENTS</code>. Все, что не входит в этот массив, является &quot;космическим&quot; событием noscript.

</p>
<p>DOM-события навешиваются через механизм делегирования.

</p>
<p>Примеры деклараций:
</p>
<pre><code class="js">{
    // событие click на корневой ноде вида
    &quot;click&quot;: &quot;onClick&quot;,
    // событие click на нодах к классом selector внутри вида
    &quot;click .selector&quot;: &quot;onSelectorClick&quot;,
    &quot;click@init .selector&quot;: &quot;onInitSelectorClick&quot;
}</code></pre>
<h4>&quot;Космические&quot; события noscript<span><a class="mark" href="#all_md_noscript" id="all_md_noscript">#</a></span></h4>
<p>Декларируются как и остальные события
</p>
<pre><code class="js">{
    &quot;my-custom-event&quot;: &quot;onCustomEvent&quot;,
    &quot;my-custom-init@init&quot;: &quot;onCustomInit&quot;
}</code></pre>
<p>Если не указано когда вешать обработчик, то оно будет навешан при показе вида и снят при скрытии.

</p>
<p>&quot;Косимческие&quot; события работают через единую шину <code>ns.events</code>
</p>
<pre><code class="js">ns.events.trigger(&#39;my-custom-event&#39;);</code></pre>
<h4>Встроенные события<span><a class="mark" href="#all_md_16" id="all_md_16">#</a></span></h4>
<p>Список событий:
<em> <code>ns-view-hide</code> - вида был скрыт и больше не виден на странице
</em> <code>ns-view-htmldestroy</code> - старая нода у вида была уничтожена
<em> <code>ns-view-htmlinit</code> - у вида появилась новая нода
</em> <code>ns-view-async</code> - у async-view появилась заглушка. Это единственное событие, которое генерируется для заглушки async-view
<em> <code>ns-view-show</code> - view был показан и теперь виден на странице
</em> <code>ns-view-touch</code> - view виден и был затронут в процессе обновления страницы

</p>
<ol>
<li>События генерируются снизу вверх, т.е. сначала их получают дочерние вида, потом родительские.</li>
<li>События генерируются пачками, т.е. сначала одно событие у всех view, потом другое событие у всех view.</li>
<li>События генерируются в строго определенном порядке, указанном выше</li>
</ol>
<p>Примеры последовательностей событий:
<em> инициализация view: <code>ns-view-htmlinit -&gt; ns-view-show -&gt; ns-view-touch</code>
</em> перерисовка страница, если view валиден: <code>ns-view-touch</code>
<em> view был скрыт: <code>ns-view-hide</code> (без <code>ns-view-touch</code>)
</em> view был показан: <code>ns-view-show -&gt; ns-view-touch</code>
* view был перерисован: <code>ns-view-hide -&gt; ns-view-htmldestroy -&gt; ns-view-htmlinit -&gt; ns-view-show -&gt; ns-view-touch</code> (<code>ns-view-hide</code> тут вызывается из тех соображений, что могут быть обработчики, которые вешаются на <code>ns-view-show/ns-view-hide</code> и при обновлении ноды, они должны быть переинициализированы)

</p>
<h3>methods<span><a class="mark" href="#all_md_methods_1" id="all_md_methods_1">#</a></span></h3>
<p><code>methods</code> - объект с методами вида. По сути является прототипом объекта.

</p>
<pre><code>/**
 * @classdesc prj.vMyView
 * @augments ns.View
 */
ns.View.define(&#39;my-view&#39;, {
    /** @lends prj.vMyView.prototype
    methods: {
        BAR: 100
        foo: function(){}
    }
});</code></pre>
<h3>models<span><a class="mark" href="#all_md_models" id="all_md_models">#</a></span></h3>
<p><code>models</code> позволяет указать модели, от которых зависит вид. Зависимость означает, что
1. параметры вида будут собраны на основе параметров связанных моделей
2. в шаблонах будут доступны вида данные связанных моделей
3. некоторые методы вида будут подписаны на события связанных моделей

</p>
<p>По умолчанию вид подписывается на следующие стандартные события модели:
 - <code>ns-model-changed</code>
 - <code>ns-model-insert</code>
 - <code>ns-model-remove</code>
 - <code>ns-model-destroyed</code>
и не подписывается на событие <code>ns-model-touched</code>.

</p>
<p>Если обработчики явно не указаны, то в качестве обработчика стандартных событий устанавливается метод <code>invalidate</code>.

</p>
<pre><code class="js">ns.View.define(&#39;super-view&#39;, {
  models: [&#39;album&#39;, &#39;photo&#39;]
});</code></pre>
<p>В приведённом примере вид будет инвалидироваться при любом стандартном событии модели.

</p>
<p>Инвалидировать вид можно так же по любым другим событиям модели. Для этого в декларации нужно явно указать событие и обработчик.

</p>
<pre><code class="js">ns.View.define(&#39;super-view&#39;, {
  models: {album: {
    &#39;ns-model-boof&#39;: &#39;invalidate&#39;
  }}
});</code></pre>
<p>Для того, чтобы предотвратить инвалидацию вида по конекретному событию, в качестве обработчика нужно явно указать метод <code>keepValid</code>.

</p>
<pre><code class="js">ns.View.define(&#39;super-view&#39;, {
  models: {album: {
    `ns-model-changed`: &#39;keepValid&#39;
  }}
});</code></pre>
<p>В приведённом примере при наступлении события ns-model-changed вид будет оставаться валидным и не будет перерисован при последующих update&#39;ах. При любом другом стандартном событии модели он будет проинвалидирован.

</p>
<p>Для того, чтобы предотвратить инвалидацию вида по любому событию, <code>keepValid</code> нужно установить значением поля модели.


</p>
<pre><code class="js">ns.View.define(&#39;super-view&#39;, {
  models: {album: &#39;keepValid&#39;}
});</code></pre>
<p>В приведённом примере события модели <code>album</code> не будут влиять на валидность вида.

</p>
<p><code>&#39;invalidate&#39; и &#39;keepValid&#39;</code> - это имена реальных методов. Вместо них можно указать имя любого другого метода вида.

</p>
<p>Если нужно в качестве обработчика события использовать произвольный метод, и при этом инвалидировать вид, достаточно внутри метода вызвать <code>this.invalidate();</code>.

</p>
<p>Для краткости вместо методов <code>invalidate</code> и <code>keepValid</code> можно указывать их краткую форму: <code>true</code> и <code>false</code> соответственно. 2 варианта деклараций в следующем примере работают одинаково.


</p>
<pre><code class="js">ns.View.define(&#39;super-view&#39;, {
  models: {
    photo: &#39;invalidate&#39;,
    album: &#39;keepValid&#39;
  }
});

ns.View.define(&#39;super-view&#39;, {
  models: {
    photo: true,
    album: false
  }
});</code></pre>
<p>Для большей краткости зависимости от моделей можно указывать в виде массива. Это будет эквивалентно указанию в качестве обработчика их событий метода <code>invalidate</code>.

</p>
<pre><code class="js">ns.View.define(&#39;super-view&#39;, {
  models: [&#39;photo&#39;, &#39;album&#39;]
});</code></pre>
<h3>Параметры<span><a class="mark" href="#all_md_17" id="all_md_17">#</a></span></h3>
<p>Параметры нужны для построения ключа.

</p>
<p>По умолчанию, если <code>params</code> не указан, то параметры собираются из параметров всех моделей в порядке их объявления.
Добавлять или удалять из собранных параметров моделей можно с помощью объектов <code>params+</code> и <code>params-</code>

</p>
<p>Если <code>params</code> явно заданы — нельзя использовать <code>params+</code> / <code>params-</code>.

</p>
<p>Если ключ view нельзя построить бросается <strong>исключение</strong>.

</p>
<h4>params+<span><a class="mark" href="#all_md_params_1" id="all_md_params_1">#</a></span></h4>
<p>Добавляет в результирующий набор дополнительные параметры:
</p>
<pre><code class="js">ns.View.define(&#39;super-view&#39;, {
  &quot;models&quot;: [ &#39;album&#39;, &#39;photo&#39; ],
  &quot;params+&quot;: { page: 23 }
});</code></pre>
<h4>params-<span><a class="mark" href="#all_md_params_2" id="all_md_params_2">#</a></span></h4>
<p>Удаляет из результирующего набора указанные параметры:
</p>
<pre><code class="js">ns.View.define(&#39;super-view&#39;, {
  &quot;models&quot;: [ &#39;album&#39;, &#39;photo&#39; ],
  &quot;params-&quot;: [ &#39;album-id&#39; ]
});</code></pre>
<h4>params<span><a class="mark" href="#all_md_params_3" id="all_md_params_3">#</a></span></h4>
<p><code>params</code> может быть массивов объектов или функцией.
Также можно указать объект - это короткая запись массива с одним элементом.

</p>
<p>Каждый объект представляет собой группу параметров.
Это позволяет строить ключ по-разному в зависимости от набора.
</p>
<pre><code class="js">ns.View.define(&#39;super-view&#39;, {
  params: [
    { &quot;context&quot;: &quot;album&quot;, &quot;album-id&quot;: null },
    { &quot;context&quot;: null }
  ]
});</code></pre>
<p>Как строится ключ:
- каждое свойство объекта — это обязательный параметр
- если значение свойства <code>null</code> — параметр обязателен, но значение его может быть любым
- если значение свойства не <code>null</code> — это <strong>фильтр</strong>, параметр из урла должен иметь именно это значение
- если есть все нужные параметры и выполняются все фильтры — ключ можно строить
- иначе — пытаемся строить по следующей группе параметров

</p>
<p>Т.о. при использовании <code>params</code> все параметры являются обязательными.
Чтобы сделать их необязательными, используйте <code>params+</code>.

</p>
<p>Если указана функция, то она строит ключ сама на основе переданных параметров.
</p>
<pre><code class="js">ns.View.define(&#39;view&#39;, {
  // ns.key - готовая функция для склеивания параметров в строку
  params: ns.key
})</code></pre>
<h3>rewriteParamsOnInit<span><a class="mark" href="#all_md_rewriteparamsoninit" id="all_md_rewriteparamsoninit">#</a></span></h3>
<p>При декларации вида можно объявить специальную функцию для обработки параметров.
Аргументом функции приходят параметры страницы, а функция должна вернуть обработанные параметры.

</p>
<p>Примеры использования:
 - вид зависит не от параметров страницы, а от названия <code>layout</code>
 - в параметры необходимо добавить какое-то фиксированное значение

</p>
<pre><code>ns.View.define(&#39;my-view&#39;, {
    rewriteParamsOnInit: function(params) {
        return {
            layout: ns.page.current.page 
        }
    }
});</code></pre>
<h2>Валидность<span><a class="mark" href="#all_md_18" id="all_md_18">#</a></span></h2>
<p>Валидность view считается по двум факторам:
- собственный статус <code>ns.V.STATUS</code>
- статус привязанных моделей

</p>
<p>При отрисовке вид запоминает все версии моделей и в дальшейшем сравнимает их. Если версия изменилась, то вид будет перерисован.

</p>
<p>Также у вида есть собственный статус <code>this.static</code> значением, которого может быть тип ns.V.STATUS. Если статус не <code>ns.V.STATUS.OK</code>, то вид будет перерисован.

</p>
<p>Инвалидировать вид можно методом <code>this.invalidate()</code>.

</p>
<p>Вид безусловно подписывается на все изменения моделей и автоматически инвалидирует себя при изменениях.

</p>
<h2>Взаимодействие<span><a class="mark" href="#all_md_19" id="all_md_19">#</a></span></h2>
<p>В noscript нет какого-либо способа получить созданный экземпляр вида.
Поэтому любое внешнее взаимодействие с ним осуществляется исключительно через механизм <a href="#События-noscript">событий noscript</a>

</p>
<h2>async<span><a class="mark" href="#all_md_async" id="all_md_async">#</a></span></h2>
<p>Вид может быть &quot;асинхронным&quot;. Такое поведение полезно, когда некоторые модели могут запрашиваться с сервера продолжительное время.

</p>
<p>Схема работы:
 1. Если у вида есть все необходимые данные (все модели валидны) для отрисовки, то он отрисуется в общем потоке.
 2. Если модели не валидны, то сначала отрисуется заглушка - мода <code>ns-view-async-content</code>, где будут доступны все валидные на данный момент данные, и сделан запрос за остальными моделями. У вида будет вызвано событие <code>ns-view-async</code>.
 3. После получения данных вид будет перерисован с обычной модой <code>ns-view-content</code> и поведет себя как обычно

</p>
<p>@include ns.view.yate
</p>
<h1>ns.ViewCollection<span><a class="mark" href="#all_md_ns_viewcollection" id="all_md_ns_viewcollection">#</a></span></h1>
<p><code>ViewCollection</code> - это коллеция <code>ns.View</code>, привязанная к <code>ns.ModelCollection</code>.
При изменении коллекции позволяет перерисовывать только изменившиеся элементы.

</p>
<p>По сути, образуется следующая зависимость один-к-одному:
</p>
<pre><code>ViewCollection      -&gt;  ModelCollection
    view-item-1     -&gt;      model-item-1
    view-item-2     -&gt;      model-item-2
                    ...
    view-item-N     -&gt;      model-item-N</code></pre>
<p><code>ns.ViewCollection</code> может зависит только от одной <code>ns.ModelCollection</code>.

</p>
<p><code>ns.ViewCollection</code> может содержать внутренние виды и иметь собственную html-разметку.

</p>
<h2>Декларация<span><a class="mark" href="#all_md_20" id="all_md_20">#</a></span></h2>
<pre><code class="js">ns.ViewCollection.define(&#39;my-view-collection&#39;, {
    models: [ &#39;my-model-collection&#39; ],
    split: {
        view_id: &#39;my-view-collection-item&#39;
    }
});</code></pre>
<p>Опция <code>split.view_id</code> определяет из каких <code>ns.View</code> состоит коллекция.

</p>
<p>Опция <code>models</code>, как и в ns.View определяет зависимость от моделей и подписки на их события.
По умолчанию ViewCollection делает следующие подписки:
 - обработчиком собственных событий <code>ns-model-changed</code> и <code>ns-model-destroyed</code> любых моделей устанавливается <code>invalidate</code>. Эти события наступают при изменении данных, по которым рисуется собственная html-разметка viewCollection&#39;а, поэтому вид по умолчанию становится невалидным, чтобы перерисоваться.
 - обработчиком <code>ns-model-insert</code> и <code>ns-model-remove</code> модели-коллекции устанавливается <code>keepValid</code>. Эти события наступают при изменении состава модели-коллекции, по которой рисуются вложенные виды viewCollection&#39;а. Собственная html-разметка при этом не затрагивается, поэтому вид по умолчанию остаётся валидным.
События моделей, вложенных в коллекцию игнорируются и подписаться на них через декларацию нельзя.


</p>
<p>Декларация элемента <code>ns.ViewCollection</code> выглядит так:
</p>
<pre><code class="js">ns.View.define(&#39;my-view-collection-item&#39;, {
    models: [ &#39;my-model-collection-item&#39; ]
});</code></pre>
<p>Элемент коллекции ведет себя как обычный <code>ns.View</code> и ничего не знает про коллекцию.

</p>
<p>Элементы коллекции помещаются в узел-контейнер, размеченный классом <code>ns-view-container-desc</code>.
Узел-контейнер <strong>обязательно</strong> должен быть указан. Вне этого контейнера можно делать собcтвенную html-разметку.

</p>
<h1>Страница<span><a class="mark" href="#all_md_21" id="all_md_21">#</a></span></h1>
<p>Noscript служит для создания одностраничных приложений. Поэтому <code>Страница</code> в контексте noscript - это то же самое, что и приложение. В приложении может быть неограниченное количество логических страниц, но все они будут показываться в рамках одного физического html-документа. Он и есть <code>Страница</code>. В noscript страница представлена объектом <code>ns.page</code>.

</p>
<h2>Адрес страницы<span><a class="mark" href="#all_md_22" id="all_md_22">#</a></span></h2>
<p>Основное состояние страницы определяется <code>Адресом страницы</code> (url). Он определяет то состояние, которое должно быть показано при загрузке/перезагрузке страницы.
Основное состояние может определяться следующими атрибутами:
 - идентификатор логической страницы (раздел сайта)
 - идентификатор сущности, оторбражаемой в приложении (id фотки, id файла)
 - атрибут состояния интерфейса, который хочется иметь возможность задавать извне (идентификатор открытого диалога)
Адрес страницы служит её <code>внешним API</code>.

</p>
<h1>Ключевые сущности<span><a class="mark" href="#all_md_23" id="all_md_23">#</a></span></h1>
<h2>Параметры страницы<span><a class="mark" href="#all_md_24" id="all_md_24">#</a></span></h2>
<p><code>Параметры страницы</code> (ns.page.params) - это параметры, получаемые из адреса страницы. ЧПУ преобразуется в объект, с которым в дальнейшем работают сущности приложения.

</p>
<h2>Маршрутизатор<span><a class="mark" href="#all_md_25" id="all_md_25">#</a></span></h2>
<p>Для преобразования адреса в параметры используется <code>маршрутизатор</code> (ns.router). Кроме параметров маршрутизатор так же возвращает идентификатор раскладки страницы (ns.layout).

</p>
<h2>Модель<span><a class="mark" href="#all_md_26" id="all_md_26">#</a></span></h2>
<p><code>Модель</code> - это элемент данных. Все данные, которые говорит и показывает интерфейс, должны быть представлены моделями. Модель может быть как клиентским представлением данных на сервере, так и локальным элементом данных, относящихся только к интерфейсу (модели состояний интерфейса).

</p>
<p>Для работы с данными сначала декларируются прототипы моделей (ns.Model.define).
Затем создаются конкретные экземпляры модели. Уникальным идентификатором экземпляра модели является свойство <code>key</code>. Свойство <code>id</code> у экземпляра модели указывает на прототип модели.

</p>
<p>Ключ модели <code>key</code> строится на основе параметров, указанных в декларации модели. К ключам стоит относиться как к хешам. Попытка парсинга ключа - это дорога в ад.

</p>
<h2>Вид<span><a class="mark" href="#all_md_27" id="all_md_27">#</a></span></h2>
<p><code>Вид</code> - это элемент интерфейса, из видов состоит страница. Вид может отображать статическое содержимое, значения параметров страницы, или данные моделей. Вид состоит из декларации и шаблона. Декларация содержит
 - <code>id</code> вида, определяющий прототип
 - модели, от которых зависит вид
 - параметры страницы, от которых зависит вид.

</p>
<p>Экземпляры видов идентифицируются атрибутом <code>key</code>. Ключ вида строится на основании параметров моделей, от которых зависит вид, и параметров, указанных в декларации вида.

</p>
<p>Экземпляры видов создаются только автоматически в результате работы контроллера обновления (ns.Updater)
Виды могут быть вложенны друг в друга. На странице всегда существует <code>корневой вид</code>, внутри которого находятся остальные виды приложения.
Существуют специальные виды: бокс, асинхронный вид, вид-коллексия.
Шаблон вида может иметь различную структуру в зависимости от используемого шаблонизатора. В комплекте с noscript идёт набор .yate шаблонов, задающих определённую структуру.
Так же есть ряд нюансов, которые нужно учитывать при написании собственных шаблонов.

</p>
<h2>Раскладка страницы<span><a class="mark" href="#all_md_28" id="all_md_28">#</a></span></h2>
<p><code>Раскладка страницы</code> (layout) - это декларация, по которой в зависимости от параметров определяется структура видов. Приложение может иметь несколько раскладок. Раскладка выбирается по идентификатору раскладки, который возвращается маршрутизатором.
Раскладка представляет собой древовидный json-объект. Каждый узел дерева соответствует виду. В ключе объекта - идентификатор прототипа вида. В значении объекта - вложенные виды. Единственный вложенный вид может быть задан строкой. Более сложная структура может быть задана объектом. Структура, зависящая от каких-то условий может быть задана функцией, которая возвращает одну из перечисленных структур. Чтобы определить вид без вложенностей, значение нужно установить в true.

</p>
<h2>Контроллер обновления<span><a class="mark" href="#all_md_29" id="all_md_29">#</a></span></h2>
<p><code>Контроллер обновления</code> (ns.Updater) - объект, реализующий логику построения и обновления страницы.

</p>

          </div>
        </div>
    </div>
    <div id="footer">
        <a href="http://joyent.com" class="joyent-logo">Joyent</a>
        <ul class="clearfix">
            <li><a href="/">Node.js</a></li>
            <li><a href="/download/">Download</a></li>
            <li><a href="/about/">About</a></li>
            <li><a href="http://npmjs.org/">npm Registry</a></li>
            <li><a href="http://nodejs.org/api/">Docs</a></li>
            <li><a href="http://blog.nodejs.org">Blog</a></li>
            <li><a href="/community/">Community</a></li>
            <li><a href="/logos/">Logos</a></li>
            <li><a href="http://jobs.nodejs.org/">Jobs</a></li>
            <li><a href="http://twitter.com/nodejs" class="twitter">@nodejs</a></li>
        </ul>

        <p>Copyright <a href="http://joyent.com/">Joyent, Inc</a>, Node.js is a <a href="/trademark-policy.pdf">trademark</a> of Joyent, Inc. View <a href="https://raw.github.com/joyent/node/v0.10.17/LICENSE">license</a>.</p>
    </div>

  <script src="../sh_main.js"></script>
  <script src="../sh_javascript.min.js"></script>
  <script>highlight(undefined, undefined, 'pre');</script>
  <script>
    window._gaq = [['_setAccount', 'UA-10874194-2'], ['_trackPageview']];
    (function(d, t) {
      var g = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      g.src = '//www.google-analytics.com/ga.js';
      s.parentNode.insertBefore(g, s);
    }(document, 'script'));
  </script>
</body>
</html>

